<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Enabling Network Traffic Obfuscation - Pluggable Transports</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.2" rel="Chapter" title="2 Background">
<link href="#rfc.section.3" rel="Chapter" title="3 Architecture Overview">
<link href="#rfc.section.4" rel="Chapter" title="4 Specification">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Pluggable Transport Naming">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 Transports API Interface">
<link href="#rfc.section.4.2.1" rel="Chapter" title="4.2.1 Goals for interface design">
<link href="#rfc.section.4.2.2" rel="Chapter" title="4.2.2 Abstract Interfaces">
<link href="#rfc.section.5" rel="Chapter" title="5 Adapters">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 API to IPC Adapter">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 PT 1.0 Compatibility">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Cross-language Linking">
<link href="#rfc.section.5.3.1" rel="Chapter" title="5.3.1 Using the Dispatcher IPC Interface In-process">
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 Anonymity Considerations">
<link href="#rfc.section.6" rel="Chapter" title="6 References">
<link href="#rfc.section.7" rel="Chapter" title="7 Acknowledgments">
<link href="#rfc.section.8" rel="Chapter" title="8 Appendix A. Changelog">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 PT 2.0, Draft 3">
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 PT 2.0, Draft 2">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.22.3 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="David Oliver, ." />
  <meta name="dct.identifier" content="urn:ietf:id:draft-oliver-pluggable-transports" />
  <meta name="dct.issued" scheme="ISO8601" content="2019-06-26" />
  <meta name="dct.abstract" content="Pluggable Transports (PTs) are a mechanism enabling the rapid development and deployment of network traffic obfuscation techniques used to circumvent surveillance and censorship. This specification does not define or limit the techniques themselves, but rather focuses on the startup, shutdown, and inter-process communication mechanisms required to make these technologies interoperable with applications." />
  <meta name="description" content="Pluggable Transports (PTs) are a mechanism enabling the rapid development and deployment of network traffic obfuscation techniques used to circumvent surveillance and censorship. This specification does not define or limit the techniques themselves, but rather focuses on the startup, shutdown, and inter-process communication mechanisms required to make these technologies interoperable with applications." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Transport Working Group</td>
<td class="right">. David Oliver</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">Guardian Project</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">June 26, 2019</td>
</tr>
<tr>
<td class="left">Expires: December 28, 2019</td>
<td class="right"></td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Enabling Network Traffic Obfuscation - Pluggable Transports<br />
  <span class="filename">draft-oliver-pluggable-transports</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>Pluggable Transports (PTs) are a mechanism enabling the rapid development and deployment of network traffic obfuscation techniques used to circumvent surveillance and censorship. This specification does not define or limit the techniques themselves, but rather focuses on the startup, shutdown, and inter-process communication mechanisms required to make these technologies interoperable with applications.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on December 28, 2019.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2019 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<li>2.   <a href="#rfc.section.2">Background</a>
</li>
<li>3.   <a href="#rfc.section.3">Architecture Overview</a>
</li>
<li>4.   <a href="#rfc.section.4">Specification</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Pluggable Transport Naming</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">Transports API Interface</a>
</li>
<ul><li>4.2.1.   <a href="#rfc.section.4.2.1">Goals for interface design</a>
</li>
<li>4.2.2.   <a href="#rfc.section.4.2.2">Abstract Interfaces</a>
</li>
</ul></ul><li>5.   <a href="#rfc.section.5">Adapters</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">API to IPC Adapter</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">PT 1.0 Compatibility</a>
</li>
<li>5.3.   <a href="#rfc.section.5.3">Cross-language Linking</a>
</li>
<ul><li>5.3.1.   <a href="#rfc.section.5.3.1">Using the Dispatcher IPC Interface In-process</a>
</li>
</ul><li>5.4.   <a href="#rfc.section.5.4">Anonymity Considerations</a>
</li>
</ul><li>6.   <a href="#rfc.section.6">References</a>
</li>
<li>7.   <a href="#rfc.section.7">Acknowledgments</a>
</li>
<li>8.   <a href="#rfc.section.8">Appendix A. Changelog</a>
</li>
<ul><li>8.1.   <a href="#rfc.section.8.1">PT 2.0, Draft 3</a>
</li>
<li>8.2.   <a href="#rfc.section.8.2">PT 2.0, Draft 2</a>
</li>
</ul><li><a href="#rfc.authors">Author's Address</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">The increased interest in network traffic obfuscation technologies mirrors the increase in usage Deep Packet Inspection (DPI) to actively monitor the content of application data in addition to that data&#8217;s routing information.  Deep Packet Inspection inspects each packet based on the header of its request and the data it carries. It can identify the type of protocol the connection is using even if it was encrypted. DPI is not a mechanism to decrypt what is inside packets but to identify the &#8216;protocol&#8217; or the application it represents.</p>
<p id="rfc.section.1.p.2">Deep packet inspection has become the prime tool of censors and surveillance entities who block, log and/or traffic-shape access to sites and services they deem undesirable.<br> As deep packet inspection has become more routine, the sophistication of monitoring has increased to include active probing that fingerprints and classifies application protocols.  Thus, even as conventional care in application design has improved (via encryption and other protocol design features that encourage privacy), network traffic is still under attack.</p>
<p id="rfc.section.1.p.3">The techniques of network monitoring are changing and improving day by day.  The development of traffic obfuscation techniques that foil these efforts is slowed by the lack of common agreement on how these techniques are invoked, made easily interoperable with applications, and deployed quickly.  This specification addresses those issues.</p>
<pre>
    &lt;!-- taken largely from PT1 spec --&gt; This specification describes a method for decoupling protocol-level obfuscation from  an application's client/server code, in a manner that promotes rapid development  of obfuscation/circumvention tools and promotes reuse across privacy tools such as VPNs and secure proxies.
</pre>
<p id="rfc.section.1.p.4">This decoupling is accomplished by utilizing helper sub-processes that implement the necessary forward/reverse proxy servers that handle the censorship circumvention, with a well defined and standardized configuration and management interface. Any application code that implements the interfaces as specified in this document will be able to use all spec compliant Pluggable Transports.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#background" id="background">Background</a>
</h1>
<p id="rfc.section.2.p.1">We define an Internet censor as any network intermediary that seeks to block, divert or traffic-manage Internet network connections for the purpose of eliminating, frustrating and/or logging access to Internet resources that have been deemed (by the censor) to be undesirable (either on a temporary or permanent basis).  A variety of techniques are commonly applied by Internet censors to block such traffic.  These include:</p>
<p></p>

<ol>
<li>DNS Blocking</li>
<li>IP Blocking</li>
<li>Protocol and Port Blocking</li>
</ol>
<p id="rfc.section.2.p.3">These techniques are applicable to a connection&#8217;s metadata (IP routing information) and do not require inspecting the connection&#8217;s datastream.</p>
<p id="rfc.section.2.p.4">DPI, in contrast, actually looks at the connection&#8217;s datastream - often, specifically, the initial data elements in the stream (or within blocks of the stream).  These elements of the stream can contain clues as to the application-level protocol employed, even when the data itself is encrypted.  With repeated exposure, these clues (&#8220;fingerprints&#8221;) can be learned by the censor and (along with the routing information) used to block or divert targeted traffic.</p>
<p id="rfc.section.2.p.5">A defense against this type of active probing is traffic obfuscation - disguising the application data itself in a manner that is less-easily fingerprinted.  But in early experiments, it quickly became clear that repeated use of the same obfuscation technique would, itself, be learned. Methods were developed by which a single obfuscation technique could transform on its own [cite FTE proxy, ScrambleSuit].  But, this approach proved expensive in terms of computational load.  Interest gathered in solving this problem and as more ideas arose so to did the need for a mechanism supporting rapid deploying of new obfuscation techniques.</p>
<p id="rfc.section.2.p.6">While intense work on network traffic obfuscation commenced initially and continues within the Tor Project (and across a wider set of external parties using Tor as a vehicle for research), vendors of other privacy-enhancing software (such as VPNs) quickly found their products also foiled by DPI.  Thus, it becomes important to see transport plug-ability as a mechanism implemented in a manner independent of a specific product or service.  The notion of &#8220;Pluggable Transports&#8221; (PT) was born from these requirements.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#architecture-overview" id="architecture-overview">Architecture Overview</a>
</h1>
<p id="rfc.section.3.p.1">The PT Server software exposes a public proxy that accepts connections from PT Clients.  The PT Client transforms the traffic before it hits the public Internet and the PT Server reverses this transformation before passing the traffic on to its next destination.  By default, the PT Server directly forwards this data to the Server App, but the Server App itself may itself be a proxy server and expect the forwarded traffic it receives to conform to a proxy communication protocol such as SOCKS or TURN. There is also an optional lightweight protocol to facilitate communicating connection metadata that would otherwise be lost such as the source IP address and port [EXTORPORT].</p>
<p id="rfc.section.3.p.2">When using the API on both client and server (&#8220;Transport API Interface&#8221;), the PT Client Library is integrated directly into the Client App and the PT Server Library is integrated directly into the Server App. The Client App and Server App communicate through socket-like APIs, with all communication between them going through the PT library, which only sends transformed traffic over the public Internet.</p>
<pre>
  +------------+                     +---------------------------+
  | Client App +-- Socket-like API --+ PT Client (Library)       +--+ 
  +------------+                     +---------------------------+  |
                                                                    | 
               Public Internet (Obfuscated/Transformed traffic) ==&gt; | 
                                                                    | 
  +------------+                       +-------------------------+  | 
  | Server App +--  Socket-like API  --+ PT Server (Library)     +--+
  +------------+                       +-------------------------+
  
           Figure 1. API Architecture Overview
</pre>
<p id="rfc.section.3.p.3">When using the transports as a separate process on both client and server, the Dispatcher IPC Interface is used. On the client device, the PT Client software exposes a local proxy to the client application, and transforms traffic before forwarding it to the PT Server. The PT Dispatcher can be configured to provide different proxy types, supporting proxying of both TCP and UDP traffic.</p>
<pre>
  +------------+                     +---------------------------+
  | Client App +---- Local Proxy ----+ PT Client (Dispatcher)    +--+ 
  +------------+                     +---+-------------------+---+  |
                                       | PT Client Library |        |
                                       +-------------------+        |
                                                                    |
             Public Internet (Transformed/Proxied traffic) =====&gt;   |
                                                                    |
  +------------+                     +---------------------------+  |
  | Server App +---- Local Proxy ----+ PT Server (Dispatcher )   +--+
  +------------+                     +---+-------------------+---+ 
                                         |PT Server (Library)| 
                                         +-------------------+

        Figure 2. IPC Architecture Overview
</pre>
<p id="rfc.section.3.p.4">A PT may also be function via Dispatcher IPC on one end of the connection but via Transport API on the other, as below (or vice-versa):</p>
<pre>
  +------------+                     +---------------------------+
  | Client App +---- Local Proxy ----+ PT Dispatcher Client      +-+ 
  +------------+                     +---+-------------------+---+ |
                                                                   |
                                                                   |
  +------------+                     +--------------------------+  | 
  | Server App +-- Socket-like API --+ PT Server (Library )     +--+ 
  +------------+                     +--------------------------+

        Figure 3. Mixed IPC and Transport API example
</pre>
<p id="rfc.section.3.p.5">Each invocation of a PT MUST be either a client OR a server.</p>
<p id="rfc.section.3.p.6">PT dispatchers MAY support any of the following proxy modes: PT 1.0 with SOCKS4, PT 1.0 with SOCKS5, PT 2.0, transparent TCP, transparent UDP, or STUN-aware UDP.  Clients SHOULD prefer PT 2.0 over PT 1.0.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#specification" id="specification">Specification</a>
</h1>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#pluggable-transport-naming" id="pluggable-transport-naming">Pluggable Transport Naming</a>
</h1>
<p id="rfc.section.4.1.p.1">Pluggable Transport names serve as unique identifiers, and every PT MUST have a unique name.  PT names MUST be valid C identifiers. PT names MUST begin with a letter or underscore, and the remaining characters MUST be ASCII letters, numbers or underscores. No length limit is imposed.  PT names MUST satisfy the regular expression &#8220;[a-zA-Z_][a-zA-Z0-9_]*&#8221;.</p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#transports-api-interface" id="transports-api-interface">Transports API Interface</a>
</h1>
<h1 id="rfc.section.4.2.1">
<a href="#rfc.section.4.2.1">4.2.1.</a> <a href="#goals-for-interface-design" id="goals-for-interface-design">Goals for interface design</a>
</h1>
<p id="rfc.section.4.2.1.p.1">The goal for the interface design is to achieve the following properties: - Transport implementers have to do the minimum amount of work in addition to implementing the core transform logic.  - Transport users have to do the minimum amount of work to add PT support to code that uses standard networking primitives from the language or platform.  - Transports require an explicit destination address to be specified. However, this can be either an explicit PT server destination with the Server App is already known implicitly (the case with obfs4), or an explicit Server App destination with the PT server destination already known implicity (the case with meek).  - Transports may or may not generate, send, receive, store, and/or update persistent or ephemeral state.  * Transports that do not need persistence or negotiation can interact with the application through the simplest possible interface * Transports that do need persistence or negotiation can rely on the application to provide it through the specified interface, so the transport does not need to implement persistence or negotiation internally.  - Applications should be able to use a PT Client implementation to establish several independent transport connections with different parameters, with a minimum of complexity and latency.  - The interface in each language should be idiomatic and performant, including reproducing blocking behavior and interaction with nonblocking IO subsystems when possible.</p>
<h1 id="rfc.section.4.2.2">
<a href="#rfc.section.4.2.2">4.2.2.</a> <a href="#abstract-interfaces" id="abstract-interfaces">Abstract Interfaces</a>
</h1>
<p id="rfc.section.4.2.2.p.1">This section presents high-level pseudocode descriptions of the interfaces exposed by different types of transport components. Implementations for different languages should provide equivalent functionality, but should use the idioms for each language, mimicking the existing networking libraries.</p>
<h1 id="rfc.section.4.2.2.1">
<a href="#rfc.section.4.2.2.1">4.2.2.1.</a> <a href="#transport" id="transport">Transport</a>
</h1>
<p></p>

<ul>
<li>Transport&#8203; takes a &#8203;transport configuration&#8203; and provides a &#8203;Client Factory&#8203; and a Server Factory.</li>
<li>Transports&#8203; may provide additional language-specific configuration methods</li>
<li>The only way to obtain &#8203;Client Factories&#8203; and &#8203;Server Factories&#8203; is from the Transport&#8203;.</li>
<li>The &#8203;Server Factory&#8203; of the &#8203;Transport&#8203; can fail if the Transport does not provide a server-side implementation, such as in the case of the meek transport. However, most transports provide both a client and server implementation.</li>
<li>The &#8203;transport configuration&#8203; is specific to each T&#8203; ransport&#8203;. Using a &#8203;Transport requires knowing the correct parameters to initialize that &#8203;Transport.</li>
</ul>
<h1 id="rfc.section.4.2.2.1.1">
<a href="#rfc.section.4.2.2.1.1">4.2.2.1.1.</a> <a href="#client-factory" id="client-factory">Client Factory</a>
</h1>
<p></p>

<ul>
<li>Client Factory&#8203; takes the &#8203;connection settings&#8203; and produces a &#8203;Connection&#8203; to that server.</li>
<li>The &#8203;connection settings&#8203; are specific to each transport. Some transports will also require an argument indicating the &#8203;destination endpoint&#8203;. Producing a Connection&#8203; may fail if the server is unreachable or if the &#8203;transport configuration&#8203; was incorrect.  ##### Server Factory</li>
<li>Server Factory&#8203; takes the address on which the PT server should listen for incoming client connections and produces a &#8203;Listener&#8203; for that address ##### Listener</li>
<li>Listener&#8203; produces a stream of &#8203;Connections</li>
<li>New &#8203;Connections&#8203; are available whenever an incoming connection from the PT client has been established. The language-specific API can adopt either a blocking or non-blocking API for accepting new connections, depending on what is idiomatic for the language.  3.2.2.2. Connection</li>
<li>Connection&#8203; provides an API similar to the environment&#8217;s native socket type</li>
<li>The connection object is extended to provide access to the underlying actual network socket used by the transport, so that low-level networking settings can be changed by the application.</li>
<li>Connection&#8203; is what is used to read and write data over the transport connection</li>
<li>The transport-specific logic for obfuscating network traffic is implemented inside the &#8203;Connection.</li>
</ul>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#adapters" id="adapters">Adapters</a>
</h1>
<p id="rfc.section.5.p.1">This section covers the various different ways that the Pluggable Transport interfaces (both API and IPC) can be adapted to different use cases.</p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#api-to-ipc-adapter" id="api-to-ipc-adapter">API to IPC Adapter</a>
</h1>
<p id="rfc.section.5.1.p.1">When an application and the transports it uses are written in the same language, either the Transports API or Dispatcher IPC can be used. When they are in different languages, they must communicate through the Dispatcher IPC interface. For maximum flexibility and to minimize duplication of effort across languages, dispatcher can be implemented by wrapping transport implementations that implement the Transports API. For an example of this approach, see the Shapeshifter Dispatcher [&#8203;https://github.com/OperatorFoundation/shapeshifter-dispatcher]&#8203; , which wraps transports implementing the Transports API in the Go language and provides a Dispatcher IPC interface to use them from other languages.</p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#pt-10-compatibility" id="pt-10-compatibility">PT 1.0 Compatibility</a>
</h1>
<p id="rfc.section.5.2.p.1">The only interface defined in the PT 1.0 specification is an IPC interface. No standard API is defined. Therefore, PT 1.0 compatibility refers to compatibility between applications and transports where one side conforms to the PT 1.0 specification and the other conforms to the PT 2.0 specification. Fortunately, an adapter is not needed in this case as both the PT 1.0 and PT 2.0 specifications allow for version negotiation. The TOR_PT_MANAGED_TRANSPORT_VER environment variable or -ptversion command line flag is used by the application to specify a list of supported versions, for instance &#8220;1.0,2.0&#8221;. The PT provider responds with the VERSION command on stdout in order to specify which version is supported by the PT provider, for instance &#8220;VERSION 2.0&#8221;. Since the application can specify a list of supported versions, the PT provider can respond dynamically, supporting PT 1.0 when required and automatically upgrading to a PT 2.0 implementation when that is an available option. It is up to applications whether they want to support PT 2.0 exclusively or maintain backwards compatibility with PT 1.0 implementations.</p>
<h1 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> <a href="#cross-language-linking" id="cross-language-linking">Cross-language Linking</a>
</h1>
<p id="rfc.section.5.3.p.1">If two languages are compatible via cross-language linking, then a suitable adapter can be written that wraps the implementation of the Transports API in one language with an API for a compatible language. For example, on Android the Go implementation of the Transports API is wrapped in a Java API to create Java language bindings without the need for a native Java implementation or use of Dispatcher IPC.</p>
<h1 id="rfc.section.5.3.1">
<a href="#rfc.section.5.3.1">5.3.1.</a> <a href="#using-the-dispatcher-ipc-interface-in-process" id="using-the-dispatcher-ipc-interface-in-process">Using the Dispatcher IPC Interface In-process</a>
</h1>
<p id="rfc.section.5.3.1.p.1">When using a transport that exposes the Dispatcher IPC interface, it may be more convenient to run the transport in a separate thread but in the same process as the application. Packets can still be routed through the transport&#8217;s SOCKS5 or TURN port on localhost. However, it may be inconvenient or impossible to use STDIN and STDOUT for communication between these two threads. Therefore, in some languages it may be appropriate to produce an &#8220;inter-thread interface&#8221; that reproduces the Dispatcher IPC interface&#8217;s semantics, but replaces STDIN and STDOUT with language-native function-call and event primitives. This is the approach used by OnionBrowser [&#8203;https://mike.tig.as/onionbrowser/&#8203;], the Tor implementation on iOS. This approach is used because Tor uses the Dispatcher IPC mechanism to talk to the transports instead of the Transports API. However, iOS does not allow for applications to have multiple processes. Therefore, an in-process Dispatcher IPC approach must be used instead of traditional separate process Dispatcher IPC. An alternative would be to use the Transports API directly instead of Dispatcher IPC.</p>
<h1 id="rfc.section.5.4">
<a href="#rfc.section.5.4">5.4.</a> <a href="#anonymity-considerations" id="anonymity-considerations">Anonymity Considerations</a>
</h1>
<p id="rfc.section.5.4.p.1">When designing and implementing a Pluggable Transport, care should be taken to preserve the privacy of clients and to avoid leaking personally identifying information.  Examples of client related considerations are: - Not logging client IP addresses to disk.  - Not leaking DNS addresses except when necessary.  - Ensuring that &#8220;TOR_PT_PROXY&#8221;&#8217;s &#8220;fail closed&#8221; behavior is implemented correctly.</p>
<p id="rfc.section.5.4.p.2">Additionally, certain obfuscation mechanisms rely on information such as the server IP address and port being confidential, so clients also need to take care to preserve server side information confidential when applicable.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#references" id="references">References</a>
</h1>
<p id="rfc.section.6.p.1">[RFC2119] Bradner, S., &#8220;Key words for use in RFCs to Indicate Requirement Levels&#8221;, BCP 14, RFC 2119, March 1997.</p>
<p id="rfc.section.6.p.2">[RFC1928] Leech, M., Ganis, M., Lee, Y., Kuris, R., Koblas, D., Jones, L., &#8220;SOCKS Protocol Version 5&#8221;, RFC 1928, March 1996.</p>
<p id="rfc.section.6.p.3">[EXTORPORT] Kadianakis, G., Mathewson, N., &#8220;Extended ORPort and TransportControlPort&#8221;, Tor Proposal 196, March 2012.</p>
<p id="rfc.section.6.p.4">[RFC3986] Berners-Lee, T., Fielding, R., Masinter, L., &#8220;Uniform Resource Identifier (URI): Generic Syntax&#8221;, RFC 3986, January 2005.</p>
<p id="rfc.section.6.p.5">[RFC1929] Leech, M., &#8220;Username/Password Authentication for SOCKS V5&#8221;, RFC 1929, March 1996.</p>
<p id="rfc.section.6.p.6">[PT2-DISPATCHER] Wiley, Brandon., Shapeshifter Dispatcher. https://github.com/OperatorFoundation/shapeshifter-dispatcher</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#acknowledgments" id="acknowledgments">Acknowledgments</a>
</h1>
<p id="rfc.section.7.p.1">Many people contributed to the PT 2.0 specification. Major contributions were made by Dr. Brandon Wiley (Operator Foundation), Nick Mathewson (Tor), and Ben Schwartz (Jigsaw).  Valuable feedback was provided by the attendees at the Pluggable Transport Implementers Meetings and the traffic-obf and tor-dev mailing lists. The PT 2.0 specification expands upon the &#8220;Pluggable Transport Specification (Version 1)&#8221; document authored by Yawning Angel (Tor). Inspiration for the PT 2.0 Go API was also inspired by the obfs4proxy implementation of the PT 1.0 specification in Go, also developed by Yawning Angel (Tor).</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#appendix-a-changelog" id="appendix-a-changelog">Appendix A. Changelog</a>
</h1>
<p id="rfc.section.8.p.1">## PT 2.1, Draft 1 - Implemented proposal 0002 - Modularization of Specification</p>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> <a href="#pt-20-draft-3" id="pt-20-draft-3">PT 2.0, Draft 3</a>
</h1>
<p></p>

<ul><li>Expanded acknowledgements section</li></ul>
<h1 id="rfc.section.8.2">
<a href="#rfc.section.8.2">8.2.</a> <a href="#pt-20-draft-2" id="pt-20-draft-2">PT 2.0, Draft 2</a>
</h1>
<p></p>

<ul>
<li>Reworded introduction</li>
<li>Removed unused Javascript and Python APIs</li>
<li>Removed SSH transport example</li>
<li>Standardized use of Transports API and Dispatcher IPC language throughout</li>
</ul>
<h1 id="rfc.authors"><a href="#rfc.authors">Author's Address</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">David M. Oliver</span> 
	  <span class="n hidden">
		<span class="family-name">David Oliver</span>
	  </span>
	</span>
	<span class="org vcardline">Guardian Project</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:david@guardianproject.info">david@guardianproject.info</a></span>

<span class="vcardline">URI: <a href="https://guardianproject.info">https://guardianproject.info</a></span>

  </address>
</div>

</body>
</html>
